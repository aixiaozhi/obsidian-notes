### setup 和 hold time
![[Pasted image 20240409140206.png]]
setup time提前到来，保持新数据的稳定，hold time时序检查确保新数据不会在触发器稳定输出初始数据之前过早到达D端而覆盖其初始数据
建立时间决定了该触发器之间的组合逻辑的**最大延迟，即频率上限**
保持时间决定了该触发器之间的组合逻辑的**最小延迟，即频率下限**
Setup Time Violation的解决方案：
1. 增大时钟周期Tcycle，即降低时钟频率
2. 减小 D->Q的传输延迟Tco，即更换更快的器件，使用更先进的器件库
3. 减小 Tcomb，即减小组合逻辑延时，主要是关键路径的处理。包括插入寄存器使其流水、重定时等。
4. 增大时钟歪斜Tskew=Tclkb-Tclka。如果时钟歪斜 Tskew 为正，对setup是有利的，对hold是有害。
hold:
1. 增加 Tcomb 延迟，增大数据的延迟具体表现为插入 Buffer
2. 增大 Tcomb，即增大组合逻辑延时，主要是关键路径的处理。可以增加Buffer，或者后端布局布线拉长布线以增加延时。
3. 减小时钟歪斜Tskew=Tclkb-Tclka。如果时钟歪斜 Tskew 为正，对setup是有利的，对hold是有害。

![[Pasted image 20240416111834.png]]
tclka:时钟传到a端耗费的时间，tclkb同理，tskew=Tclkb-Tclka，tco：在D寄存器内传输的时间，Tdata：中间的组合逻辑的时间
![[Pasted image 20240416112357.png]]
hold是怕下个信号翻转太快直接淹没了此级的信号
Tclka+Tdata+Tco>Thold+Tclkb,所以skew越大越不利于hold满足
Tclka+Tdata+Tco<Tclkb+Tsetup,skew越大越利于setup满足


### 亚稳态
**多用几级寄存器打拍可以消除亚稳态（错误）** B.亚稳态是极不稳定的，理论上来讲处在亚稳态的时间可以无限长。 C.亚稳态稳定到 0 或者 1，是随机的，与输入没有必然的关系。 D.如果数据传输中不满足触发器的建立时间 Tsu 和保持时间 Th，可能产生亚稳态。

### verilog
**注意begin end**是过20之后赋给0
```verilog
fork begin A=1； #20 A=0； #30 A=1； #50 A=0; end begin B=1； #20 B=0； #30 B=1； #50 B=0. End join
```
在45这个时间，A和B都是1

Moore型状态机和Mealy型状态机区别是**输出与输入**是否相关
相互间相位固定且频率相同的时钟就是**同步时钟**
1Mhz是10的6次方 200ns/5Mhz
![[Pasted image 20240416125332.png]]
generate也可综合


### system verilog
```
class C1； rand int m； constraint c1_ cons { m<=10；} endclass class C2 extends C1； constraint c1_cons { m>=10； } endclass
```
在扩展类中定义了一个约束，并且扩展后的约束名和基类里的约束名相同，那么扩展类的约束就会替代基类中的约束 最后是m>=10
sv中默认的成员属性是public

### 代码和功能覆盖率
代码覆盖率：工具会自动搜集已经编写好的代码，常见的代码覆盖率如下：
**行覆盖率**（line coverage）：记录程序的各行代码被执行的情况。
**条件覆盖率**（condition coverage）：记录各个条件中的逻辑操作数被覆盖的情况。
**跳转覆盖率**（toggle coverage）：记录单bit信号变量的值为0/1跳转情况，如从0到1，或者从1到0的跳转。
**分支覆盖率**（branch coverage）：又称路径覆盖率（path coverage），指在if，case，for，forever，while等语句中各个分支的执行情况。
**状态机覆盖率**（FSM coverage）：用来记录状态机的各种状态被进入的次数以及状态之间的跳转情况。
功能覆盖率：用户定义的功能度量，即使100%也不能说全部验证完了
面向数据的覆盖率（Data-oriented Coverage）-对已进行的数据组合检查.我们可以通过编写覆盖组（coverage groups）、覆盖点（coverage points）和交叉覆盖（cross coverage）获得面向数据的覆盖率.
面向控制的覆盖率（Control-oriented Coverage）-检查行为序列（sequences of behaviors）是否已经发生.通过编写SVA来获得断言覆盖率(assertion coverage).
需要指出的是: **代码覆盖率达到要求并不意味着功能覆盖率也达到要求，二者无必然的联系。而为了保证验证的完备性，在收集覆盖率时，要求代码覆盖率和功能覆盖率同时达到要求。**


### 功耗
动态功耗来自：1.门翻转负载电容充放电 **翻转功耗** 2. pmos和nmos串并联结构都导通时候的短路电流 **短路功耗**
解决方法：门控时钟，减小毛刺，减小负载电容，动态功耗与电压的平方有关系，降低电压，动态电压调整，降低频率，谐振电路

静态功耗来自：亚阈值泄漏电流，栅泄露，结泄露电流，竞争电流
解决方法：电源门控（关闭休眠模块的电源），多种阈值电压和栅氧厚度，输入向量控制

### 综合
综合包括转换(translation)、优化 (optimization)与映射(mapping) **三**个阶段
Translation 是指把 HDL 语言描述的电路转化为用 GTECH 库元件组成的逻辑电路的门的过程
优化 (optimization)是综合工具对已有的初始电路进行分析，去掉电路中的冗余单元，并对不满足限制条件的路径进行优化
Mapping 把用 GTECH 库元件构成的电路映射到某一特定厂家的工艺库上

数字芯片的工作条件（PVT）工艺、电压、温度

**格雷码是一次跳变只有相邻的一位变化，独热码是只有一位为1**

### 跨时钟域传输
单比特信号：慢到快：寄存器打两拍，快到慢：用两级DFF同步的方法已经无法满足了(慢时钟域仍然无法采集到信号)，此时我们就引入了脉冲展宽信号，把快时钟域的信号多稳定一段时间，等到慢时钟域采到了，再拉低，如此便能保证数据的跨时钟域传输。
多比特：格雷码加打拍（相当于异步FIFO），握手协议，D触发器加二选一选择器，数据使能选通设计

### 静态时序分析的限制
STA的一些限制如下：
（1）只有时序仿真可以验证复位的问题，而STA无法进行检查。
（2）STA只能识别0-1-上升沿-下降沿这几种信号，而没办法检查不定态。
（3）STA无法合适的载入或者设置PLL。
（4）STA无法检查异步时钟的问题。
（5）STA也没办法验证特定的IO接口需求。
（6）STA没办法检查模拟和数字电路之间的接口。
（7）STA可能会把电路中某些从来不会使用的路径标记为false path。
（8）STA无法检测到两个有限状态机的同步问题。
（9）STA无法检测到时钟生成与时钟定义不匹配的问题。
（10）STA没办法检查跨越多个时钟周期的行为















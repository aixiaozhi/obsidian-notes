### **10.13中午与胡九龙**
在同一个进程中，确实有可能多个虚拟地址对应同一个物理地址，页表就是存了这种情况，两个VPN映射到同一个PFN，虽然操作系统不太会这么做，但是写操作系统代码（软件）的人确实可以写出来这样的case，s模式是可见物理地址的，m模式不可见虚拟地址。那也就是说，在store_q里面确实有可能会存在同一个进程的情况下，多个虚拟地址对应同一个物理地址的情况。
不同进程切换的时候就更有可能多个虚拟地址对应同一个物理地址了。   

原来想的进程切换flush掉TLB和store_q就可以采用虚地址前递这件事是不可以的，必须要有物理地址的检查，最好的能优化的情况我想到的是直接采用虚地址前递，这样不用访问TLB，很快，但是后续必须引入实地址检查，如果不匹配就要回滚，这样就需要一个单独的表项来记录这件事，会比较麻烦，面积开销也会比较大。

所以现在前递必须这么做：
虚地址匹配产生匹配向量拿出data，然后实地址匹配仍产生匹配向量，对比匹配向量
**不能**由虚地址产生匹配向量，然后去那个entry对比实地址的原因是，即使实地址相等了，也不能说明前递的就是这个entry。假设store_q里面存在两个entry

| va  | pa | data |
| --- | --- | ----- |
| va1 | pa1 | data1 |
| va2| pa1| data2|
查询的load指令是va1和pa1 但是store_mask是000011 对比va匹配是第0个entry，如果紧接着对比pa就会发现前递成功，但是实际是要前递第二个entry。所以需要分别对比va和pa产生匹配向量进行对比。

发现前递失败现在采用最保守的策略：直接放弃这次前递，走load流水线正常写回数据，会由store-load违例机制检查出错误的。

### **10.19晚上发现的问题**ali
进程切换的时候可能会出现两个不同的case，两个va对应同一个pa，和一个va对应两个pa
<table border="1">
      <tr>
        <th colspan="3">case1</th>
        <th colspan="3">case2</th>
    </tr>
    <tr>
        <td>va</td>
        <td>pa</td>
        <td>data</td>
        <td>va </td>
        <td>pa </td>
        <td>data</td>
    </tr>
    <tr>
        <td>va1</td>
        <td>pa1</td>
        <td>data1</td>
        <td>va1</td>
        <td>pa1</td>
        <td>data1</td>
    </tr>
     <tr>
        <td>va2</td>
        <td>pa1</td>
        <td>data2</td>
        <td>va1</td>
        <td>pa2</td>
        <td>data2</td>
    </tr>
</table>

如果在va2,pa2之后进程切换回去有访问的va1,pa1，这种情况就是store-load违例检测不出来的，检查到不匹配必须重新从取指执行。这样就分三个平行的违例线，store-load，load-load，虚实地址不匹配造成的违例。